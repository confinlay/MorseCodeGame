#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include "pico/stdlib.h"

#include "hardware/gpio.h"
#include "hardware/watchdog.h"
#include "pico/time.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "ws2812.pio.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

#define MAXSIZE 100

char* morseCode[] = {"-----", ".----", "..---","...--", "....--", ".....", "-....", "--...", "---..", "----.",".-", "-...", "-.-.", "-..", ".", "..-.",
    "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-",
    ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};

char* words[] = {
    "ace", "apple", "blue", "bunny", "cape",
    "chair", "daisy", "dance", "eagle", "ember",
    "frost", "fudge", "glide", "grape", "honey",
    "icicle", "jazz", "jelly", "kangaroo", "kitten",
    "lemon", "lucky", "marble", "mango", "navy",
    "ocean", "opal", "pepper", "piano", "quilt",
    "rabbit", "river", "sunny", "swirl", "tiger",
    "turtle", "umbrella", "unique", "violet", "wave",
    "wheat", "whisk", "yellow", "lunch", "zebra",
    "acorn", "badger", "banana", "butter", "cactus",
    "coffee", "comet", "dagger", "dragon", "flamingo",
    "gorilla", "guitar", "hippo", "hockey", "jungle",
    "ketchup", "kiwi", "koala", "laptop", "lizard",
    "mascot", "monkey", "mountain", "mustard", "necklace",
    "octopus", "penguin", "pumpkin", "rainbow", "robot",
    "sailor", "seagull", "shark", "snowman", "squirrel",
    "treasure", "unicorn", "volcano", "watermelon", "whale",
    "wizard", "xylophone", "yak", "yellowstone", "zeppelin"
};

// Must declare the main assembly entry point before use.
void main_asm();
// Initialise a GPIO pin – see SDK for detail on gpio_init()
void asm_gpio_init(uint pin) {
 gpio_init(pin);
}
// Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
void asm_gpio_set_dir(uint pin, bool out) {
 gpio_set_dir(pin, out);
}
// Get the value of a GPIO pin – see SDK for detail on gpio_get()
bool asm_gpio_get(uint pin) {
 return gpio_get(pin);
}
// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
 gpio_put(pin, value);
}

// Enable falling-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irq(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

// Enable rising-edge interrupt 
void asm_gpio_set_irq1(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}

void welcomeMessage();
char* convertMorse(char* word);

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

static inline void led_set_blue() {
    put_pixel(urgb_u32(0x00, 0x00, 0x7F));
}

static inline void led_set_red() {
    put_pixel(urgb_u32(0x7F, 0x00, 0x00));
}

static inline void led_set_orange() {
    put_pixel(urgb_u32(0xFF, 0x8C, 0x00));
}
static inline void led_set_green() {
    put_pixel(urgb_u32(0x00, 0xFF, 0x00));
}
static inline void led_set_off() {
    put_pixel(urgb_u32(0x00, 0x00, 0x00));
}
static inline void led_set_yellow() {
    put_pixel(urgb_u32(0xD7, 0xFF, 0x00));
}

//initialise watchdog timer
void watchdog_init(){
    if(watchdog_caused_reboot){
        printf("Game Restarted due to inactivity!\n");
    }
    //enable the watchdogtimer set to the max time, approx 8.3 secs
    //One sets the watchdog timer to pause during debug 
    watchdog_enable(0x7fffff, 0); 
    watchdog_update();
}

//Initialising variables
//need to be global cuz we jump in and out of ASM
int interrupt_occured = 0;               //to indicate that an interrupt needs to be dealt with   
int start_high = 0;                      //set to 1 once first button press has been released (first rising edge interrupt)
int start_low = 0;                       //set to 1 once second button press has occured (second falling edge interrupt)
int i = 0;                               //used to track position in the array
int k = 0;                               //used to track place in first_seq array - if inputting the first char it should = 0, any char after it should = 1
bool edge_type = true;                   //when set to true, the button release is being dealt with. when set to false, button pressed
uint32_t low_interval, high_interval;    //to store the latest time segments
uint32_t time_intervals[100];                 //array to hold the time_intervals input (4 dots/dashes, 3  s)
int process_sequence = 0;                //set to 1 when the 2 second alarm timer goes off, program knows to take the users input and process it
int space_timer = 0;
int lives = 3;                           //lives set to 3 at the start
int score = 0;                           //score set to 0 at the start
char character;                          //the character the user should input morse for
int repeat = 0;                          //used in the levels to repeat the same character or generate another one based on if the user input the correct code
int level_choice;                        //to decide which level to play
char randomWord[8];

bool alarm_1_done = false;
bool alarm_2_done = false;

//sets the start_high variable to 1 - to be called from ASM
//sets alarm_1_done and alarm_2_done to false to enable alarm interrupts being handled 
void set_start_high(int i){
    start_high = i;
    alarm_1_done = false;
    alarm_2_done = false;
}

//sets the start_low variable to 1 - to be called from ASM
void set_start_low(int i){
    start_low = i;
}

//sets the interrupt flag variable to high - to be called from ASM
void check_for_interrupt(int signal){
    interrupt_occured = signal;
}

//stores the interval between button presses
void store_interval_low(int interval){
    low_interval = interval;
}

//stores the interval the button has been pressed for
void store_interval_high(int interval){
    high_interval = interval;
}

//used to put a null terminator on the end of the string of morse code so it can be used in comparison function
void null_terminate_string(char *morse_string){
    int i = 0; //counter
    
    //find the end of the morse code
    while (morse_string[i] == '.' || morse_string[i] == '-'|| morse_string[i] == ' '){
        i++;  
    }

    morse_string[i] = ' '; //space so that it is compatible with ConvertMorse function
    morse_string[i+1] = '\0'; //null terminate
}

//takes an array of uint32_t values, times between rising and falling edge interrupts
//converts the times between falling and rising edge to 1's (dashes) and 0's (dots)
void convert_to_morse(uint32_t intervals[], char *morse_string, int k){
    int counter = 0; 
    while (time_intervals[k] != 0){                                  //to loop over the array of times
        if (time_intervals[k] <= 150000){                            //if button was pressed for less than 0.15 s
        morse_string[counter] = '.';                            //it is a dot
        } 
        if (time_intervals[k] <= 1000000 && time_intervals[k] > 150000){  //if button was pressed for between 0.15 and 1 s 
        morse_string[counter] = '-';                            //it is a dash
        }
        if (time_intervals[k] > 1000000){                            //if the button was pressed for more than 1 s
        morse_string[counter] = ' ';                            //it is not recognised
        }
        counter++;                                              //move to the next place in the array 
        k = k + 2;                                              //move two places in the time_intervals array
    }
    null_terminate_string(morse_string);
}


void handle_gpio_interrupt() {
    if (edge_type && start_high == 1){      //if the button has just been released (rising edge) and we are passed the starting phase
        i++;                                //increment the counter to move along in the array
        time_intervals[i-1] = high_interval;//store the time interval in the array (dot / dash)
        edge_type = false;                  //set edge_type so that next interrupt it will deal with a button press (falling edge)
        interrupt_occured = 0;              //to indicate we have dealt with the interrupt occuring
    } else {                            
        if (start_low == 1){                //if the button has been pressed and we are past the starting phase
            i++;                            //increment the counter to move along in the array
            time_intervals[i-1] = low_interval;  //store the time interval (spaces)
            edge_type = true;               //set the edge_type so that next interrupt will deal with a button released
            interrupt_occured = 0;          //to indicate we hae dealt with the interrupt occuring  
        } 
      }
}

// Return a random character from 0-9 or A-Z when called
char randomChar(int choose_level) {
    char random_char;

    // Use the current microsecond count to seed the random number generator
    uint64_t seed = time_us_64();
    srand(seed);

    // Generate a random number (0 - 9: numbers; 10 - 35: letters)
    int random_num = rand() % 35;

    // If 0 -> 9, return straight away
    // Otherwise, convert the number to an uppercase letter and return the letter
    if (random_num < 10) {
        random_char = random_num + '0';
    } else {
        random_char = (random_num - 10) + 'A';
    }
    char* random_morse = morseCode[random_num];

    // Print statements
    if (choose_level == 1){
        printf("|                 Character: %c | Morse code equivalent: %s                  |\n", random_char, random_morse);
        printf("|                                                                              |\n");
    } else if (choose_level == 2) {
        printf("|                 Character: %c | Morse code equivalent not shown              |\n", random_char);
        printf("|                                                                              |\n");
    }

    // Return character for checking later
    return random_char;

}


void output_user_input(char* input, char *morse){
    printf("|                                                                              |\n");
    printf("|                        You input %s : %s                                    |\n", morse, input);
    printf("|                                                                              |\n");
    return;
}


/**
 * @brief Handles alarm interrupts coming every 1 second from arm .
 * 
 * if alarm_2_done is true then ignore all alarm interrupts- this will be reset to false after a GPIO interrupt
 * if alarm_2_done and alarm_1_done are false then handle a space being input 
 * if alarm_2_done is false and alarm_1_done is ture then handle the netire user input
 * 
 * @param alarm_1_done set to true after the first alarm interrupt following a GPIO interrupt
 * @param alarm_2_done set to true after the second alarm interrupt following a GPIO interrupt
 */
void handle_alarm(){
    if (!alarm_2_done){
        if (!alarm_1_done){
            printf("one second has passed!\n");
            space_timer = 1;
            alarm_1_done = !alarm_1_done;
        }else{
            printf("two seconds have passed!\n");
            process_sequence = 1;
            alarm_2_done = !alarm_2_done;
        }

    }
    return;
}

//printing entry message level 1
void print_level_one(){
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|                            Welcome to Level 1                                |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    return;
}

//printing entry message level 2
void print_level_two(){
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|                            Welcome to Level 2                                |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    return;
}

//printing entry message level 3
void print_level__three(){
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|                            Welcome to Level 3                                |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    return;
}

//printing entry message level 4
void print_level_four(){
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|                            Welcome to Level 4                                |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    return;
}

//printing level complete messages
void level_complete_message(int choose_level){
    if (choose_level == 1){
        printf("|                     Congratulations, you passed level 1 !                    |\n");
        printf("|                                                                              |\n");
        printf(".______________________________________________________________________________.\n");
        level_choice = 2;
    } else if (choose_level == 2){
        printf("|                     Congratulations, you passed level 2 !                    |\n");
        printf("|                                                                              |\n");
        printf(".______________________________________________________________________________.\n");
    }
}

//used to clear the array storing the timer intervals
void clear_time_intervals(){
    int x = 0;
        while(time_intervals[x] != 0){
            time_intervals[x] = 0;
            x++;
        }
}

//level one and two, depending on what "choose_level" is input. 1 for level 1, 2 for level 2. 
int level_one_and_two(int choose_level) {
    if (choose_level == 1){ //print the level 1 entry message
        print_level_one();
    } else if (choose_level == 2) { //print the level 2 entry message
        print_level_two();
    } else {
        printf("error in choosing level!\n"); //print error
    }

    //char character; 
    //loop until the player completes the level or runs out of lives
    while (lives != 0 && score != 5){
        //output the colour corresponding to the amount of lives yet
        switch (lives) {
        case 3: 
            led_set_green();
            break;
        case 2:
            led_set_orange();
            break;
        case 1:
            led_set_yellow();
            break;
        default:
            break;
        }

        if (repeat == 1){ //if the user input the wrong sequence of morse code
            printf("|                                Try again !                                   |\n");
            printf("|                                                                              |\n");
        } else { //output a new random character for the user to input
            character = randomChar(level_choice);
          } 
        
        i = 0;                              //global counter for morse code inputs 
        while (process_sequence != 1){      //until the alarm goes off, accept inputs
            if (interrupt_occured){         //input occured
                handle_gpio_interrupt();    //deal with new input  
            }
        }
        process_sequence = 0;               //set to zero so we pause at the while loop the next iteration

        //alarm has gone, convert the sequence of time intervals to morse code
        char morse_sequence[7];                          //only 7 chars since all letters / nums can be represented by 5 dots / dashes
        convert_to_morse(time_intervals, morse_sequence, k);  //convert the sequence to morse code

        char *user_input;                   //string (one char) to hold what the user has input in letters / numbers
        char *morse = morse_sequence;       //string to hold what the user has input in dots and dashes
        user_input = convertMorse(morse);   //convert the dots and dashes to the letter / char

        output_user_input(user_input, morse); //output the users input

        if (user_input[0] == character){  //if the users input is correct
            score++;        //add one to the score and get a new character (start while loop again)
            if (lives < 3){ //if we are not already on 3 lives, add another life
                lives++;
            
            repeat = 0; //set repeat to 0 so that we get a new character on the next iteration
            }
           
        }else {
            printf("%s : %c\n", user_input, character);
            lives--;        //didn't match so minus 1 life and get a new character (start while loop again)
            repeat = 1;     //set repeat to 1 since we need the user to attempt the same character again
        }
        
        //clear the time_intervals array
        clear_time_intervals();
        
        //reset variables for the next round (next iteration of the while loop)
        start_high = 0;                                    //to not accept the first interrupt 
        k = 1;                                             //for use in function convert_to_morse. odd time intervals will be used after first round
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round
    }
    

    if (lives == 0){
        led_set_red(); //set led to red 
        printf("|                You have failed to complete the level :(                      |\n");
        printf("|                                                                              |\n");
        printf(".______________________________________________________________________________.\n");
        lives = 3;  //reset lives
        score = 0;  //reset score
        repeat = 0; //don't enter repeat next iteration
        return 1;   //you lost
    } else {
        led_set_yellow();   //set the LED to yellow to indicate you won (PROB CHANGE THIS !)
        level_complete_message(level_choice); //print winning message
        lives = 3;  //reset lives
        score = 0;  //reset score
        return 0;   //!! you won 
    }

}
int level_three_and_four(int choose_level){
    int randomNumber;
    int first = 1;
    char *morse;
    char morse_sequence[7];

    if(choose_level == 1)
        print_level__three();
    else if(choose_level == 2)
        print_level_four();
    else 
        printf("error in choosing level!\n");
    
    while(lives != 0 && score != 5){
        switch (lives) {
        case 3: 
            led_set_green();
            break;
        case 2:
            led_set_orange();
            break;
        case 1:
            led_set_yellow();
            break;
        default:
            break;
        }

        if (repeat == 1){ //if the user input the wrong sequence of morse code
            printf("|                                Try again !                                   |\n");
            printf("|                                                                              |\n");
        } else{
            uint64_t seed = time_us_64();
            srand(seed);
            randomNumber = rand() % 100;
            strcpy(randomWord, words[randomNumber]);
            printf("Your word is : %s\n", randomWord);
        }
        
        i = 0;

        while (process_sequence != 1){
            while(space_timer != 1){
                if(interrupt_occured)
                    handle_gpio_interrupt();
            }
            space_timer = 0;
            convert_to_morse(time_intervals, morse_sequence, k);
            if (first)
                morse = morse_sequence;
            else 
                strcat(morse, morse_sequence);
            first = 0;
        }
        process_sequence = 0;

        char *user_input = convertMorse(morse);

        output_user_input(user_input, morse);

        if(strcmp(user_input, randomWord) == 0){
            score++;
            if (lives < 3){
                lives ++;
                repeat = 0;
            }
        } else{
            lives--;
            repeat = 1;
        }

            clear_time_intervals();

            start_high = 0;
            k = 1;
            memset(morse_sequence, 0, sizeof(morse_sequence));
        }

        if(lives == 0){
            led_set_red();
            printf("|                You have failed to complete the level :(                      |\n");
            printf("|                                                                              |\n");
            printf(".______________________________________________________________________________.\n");
            lives = 3;
            score = 0;
            repeat = 0;
            return 1;
        } else {
            led_set_yellow();
            level_complete_message(level_choice);
            lives = 3;
            score = 0;
            return 0;
        }
    }


int choose_level() {
    while (process_sequence != 1){      //until the alarm goes off, accept inputs
        if (interrupt_occured){         //input occured
            handle_gpio_interrupt();    //deal with new input  
        }
    }
    process_sequence = 0;               //set to 0 so that we enter the while loop on the next iteration

    char morse_sequence[7];                          //only 7 chars since all letters / nums can be represented by 5 dots / dashes
    convert_to_morse(time_intervals, morse_sequence, k);  //convert the sequence to morse cod  

    char *morse = morse_sequence;       //string to hold what the user has input in dots and dashes
    
    if (strcmp(morse,".---- ") == 0){
        clear_time_intervals();                            //clear the array of time intervals
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round
        k = 1;                                             //set k to 1 so we take every odd interval from the time array (see function convert_to_morse)
        return 1; //level one selected
    } else if (strcmp(morse,"..--- ") == 0) {
        clear_time_intervals();                            //clear the array of time intervals
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round    
        k = 1;                                             //set k to 1 so we take every odd interval from the time array (see function convert_to_morse)
        return 2; //level two selected
    } else {
        clear_time_intervals();                            //clear the array of time intervals
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round    
        i = 0;                                             //set the index counter of the time_interval to zero
        k = 1;                                             //set the index counter of the morse code array to zero
        return 0; //no level selected
    }


}

// Main entry point of the application
int main() {
    //initialising
    stdio_init_all(); 
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &ws2812_program);
    ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);

    //watchdog_init(); // initialise watchdog timer
    main_asm(); // initialise pins and interrupt
    welcomeMessage(); // print welcome message
    
    led_set_blue(); // to indicate that no game is in play 


    while (level_choice == 0){ //NEEDS TO BE MADE ROBUST
        level_choice = choose_level(); //get the users input for level choice
        if (level_choice == 1 || level_choice == 2){ break; }
        printf("|                                                                              |\n");
        printf("|               Error when choosing level. Please choose again.                |\n");
        printf("|                                                                              |\n");
    }

    int level; //placeholder
    level = level_three_and_four(level_choice);   //start whichever level the user chose
    if (level == 0){ //if we passed level 1, go to level 2
        level = level_three_and_four(level_choice);   //start whichever level the user chose
    }

    while (1){ //to keep program running so i can pause debugger before program quits

    };

    return(0);
}


// Print the welcome message
void welcomeMessage() {
    // 80 char width, pipes inclusive
    printf(".______________________________________________________________________________.\n");
    printf("|                    _____ _____   ____  _    _ _____    __                    |\n");
    printf("|    Conor          / ____|  __ \\ / __ \\| |  | |  __ \\  /_ |            Joe    |\n");
    printf("|    Finlay        | |  __| |__) | |  | | |  | | |__) |  | |        Mulvany    |\n");
    printf("|                  | | |_ |  _  /| |  | | |  | |  ___/   | |                   |\n");
    printf("|    Fionnan       | |__| | | \\ \\| |__| | |__| | |       | |        Tiernan    |\n");
    printf("|    O\'Sullivan     \\_____|_|  \\_\\\\____/ \\____/|_|       |_|         Mullen    |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|         ___           ___           ___           ___           ___          |\n");
    printf("|        /\\__\\         /\\  \\         /\\  \\         /\\  \\         /\\  \\         |\n");
    printf("|       /::|  |       /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\        |\n");
    printf("|      /:|:|  |      /:/\\:\\  \\     /:/\\:\\  \\     /:/\\ \\  \\     /:/\\:\\  \\       |\n");
    printf("|     /:/|:|__|__   /:/  \\:\\  \\   /::\\~\\:\\  \\   _\\:\\~\\ \\  \\   /::\\~\\:\\  \\      |\n");
    printf("|    /:/ |::::\\__\\ /:/__/ \\:\\__\\ /:/\\:\\ \\:\\__\\ /\\ \\:\\ \\ \\__\\ /:/\\:\\ \\:\\__\\     |\n");
    printf("|    \\/__/~~/:/  / \\:\\  \\ /:/  / \\/_|::\\/:/  / \\:\\ \\:\\ \\/__/ \\:\\~\\:\\ \\/__/     |\n");
    printf("|          /:/  /   \\:\\  /:/  /     |:|::/  /   \\:\\ \\:\\__\\    \\:\\ \\:\\__\\       |\n");
    printf("|         /:/  /     \\:\\/:/  /      |:|\\/__/     \\:\\/:/  /     \\:\\ \\/__/       |\n");
    printf("|        /:/  /       \\::/  /       |:|  |        \\::/  /       \\:\\__\\         |\n");
    printf("|        \\/__/         \\/__/         \\|__|         \\/__/         \\/__/         |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\  \\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\__\\   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/__/ \\:|__| /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  \\  \\/__/ \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\  \\        \\:\\  /:/  /   \\:\\  /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\  \\        \\:\\/:/  /     \\:\\/:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\:\\__\\        \\::/  /       \\::/__/       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         ~~            \\/__/                 |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\__\\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::|  |       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:|:|  |      /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /::\\~\\:\\  \\   /:/|:|__|__   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/_\\:\\__\\ /:/\\:\\ \\:\\__\\ /:/ |::::\\__\\ /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  /\\ \\/__/ \\/__\\:\\/:/  / \\/__/~~/:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\ \\:\\__\\        \\::/  /        /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\/:/  /        /:/  /        /:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\::/  /        /:/  /        /:/  /       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         \\/__/         \\/__/                 |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|           Enter a sequence of dots and dashes using GP21 to begin!           |\n");
    printf("|                                                                              |\n");
    printf("|                            Level 1 : .----                                   |\n");
    printf("|                            Level 2 : ..---                                   |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
}


char* convertMorse(char* word){
    char* converted = (char*)malloc(MAXSIZE);                           // allocate memory space for output string
    int converted_index = 0, word_index = 0, letter_index = 0;          // initiliase index counters to 0
    char letter[MAXSIZE] = " ";                                         // declare char array to temporarily store each letter
    bool found = false;

    while(word[word_index] != '\0'){                                    // while there are still more code signals to read in
        if(word[word_index] == ' ')  {                                  // if we read in a space, then we have finished a letter
            word_index++;                                               // increment to next morse code signal for default flow following this if statement
            letter[letter_index] = '\0';                                // null-terminate string containing morse code for the letter
            for (int i = 0; i < 35; i++){                               // for each letter in the alphabet
                if (strcmp(letter,morseCode[i]) == 0){                  // check if the morse code produced so far is equal to a letter in the alphabet
                    found = true;                                       // set found to true
                    if(i < 10)
                        converted[converted_index++] = i + '0';         // add number to output if it is and post-increment converted_index
                    else
                        converted[converted_index++] = (i - 10) + 'A';  // add letter to output if it is and post-increment converted_index
                }               
                letter_index = 0;                                       // start new letter
            }
            if(!found){                                                 // if no letter found
                converted[converted_index++] = '?';                     // set letter to ? for unknown        
            }
            found = false;                                              // set found to false regardless
        }    
                                                     
        letter[letter_index++] = word[word_index++];                    // either way, read in another characted from the input, post incrementing both char arrays
    }
    converted[converted_index] = '\0';                                  // null-terminate output (removing trailing question mark)
    return converted;                       
}
