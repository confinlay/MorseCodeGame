#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "pico/stdlib.h"

#include "hardware/gpio.h"
#include "hardware/watchdog.h"
#include "pico/time.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "ws2812.pio.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

#define MAXSIZE 100

char* morseCode[] = {"-----", ".----", "..---","...--", "....--", ".....", "-....", "--...", "---..", "----.",".-", "-...", "-.-.", "-..", ".", "..-.",
    "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-",
    ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};

// Must declare the main assembly entry point before use.
void main_asm();
// Initialise a GPIO pin – see SDK for detail on gpio_init()
void asm_gpio_init(uint pin) {
 gpio_init(pin);
}
// Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
void asm_gpio_set_dir(uint pin, bool out) {
 gpio_set_dir(pin, out);
}
// Get the value of a GPIO pin – see SDK for detail on gpio_get()
bool asm_gpio_get(uint pin) {
 return gpio_get(pin);
}
// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
 gpio_put(pin, value);
}

// Enable falling-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irq(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

// Enable rising-edge interrupt 
void asm_gpio_set_irq1(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}

void welcomeMessage();
char* convertMorse(char* word);

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

static inline void led_set_blue() {
    put_pixel(urgb_u32(0x00, 0x00, 0x7F));
}


//initialise watchdog timer
void watchdog_init(){
    if(watchdog_caused_reboot){
        printf("Game Restarted due to inactivity!\n");
    }
    //enable the watchdogtimer set to the max time, approx 8.3 secs
    //One sets the watchdog timer to pause during debug 
    watchdog_enable(0x7fffff, 0); 
    watchdog_update();
}

//Initialising variables
//need to be global cuz we jump in and out of ASM
int interrupt_occured = 0;               //to indicate that an interrupt needs to be dealt with   
int start_high = 0;                      //set to 1 once first button press has been released (first rising edge interrupt)
int start_low = 0;                       //set to 1 once second button press has occured (second falling edge interrupt)
int i = 0;                               //used to track position in the array
bool edge_type = true;                   //when set to true, the button release is being dealt with. when set to false, button pressed
uint32_t low_interval, high_interval;    //to store the latest time segments
uint32_t first_seq[7];                   //array to hold the first_seq input (4 dots/dashes, 3 spaces)

//sets the start_high variable to 1 - to be called from ASM
void set_start_high(int i){
    start_high = i;
}

//sets the start_low variable to 1 - to be called from ASM
void set_start_low(int i){
    start_low = i;
}

//sets the interrupt flag variable to high - to be called from ASM
void check_for_interrupt(int signal){
    interrupt_occured = signal;
}

//stores the interval between button presses
void store_interval_low(int interval){
    low_interval = interval;
}

//stores the interval the button has been pressed for
void store_interval_high(int interval){
    high_interval = interval;
}


//gets the first sequence of inputs from gpio21, should track 4 button presses (7 places in the array, 4 presses, 3 spaces)
//to use this function again, the variables start_high, start_low and edge_type might need to be reset, havnt tested that yet
void get_first_seq(){
    while (i < 7){
        if (interrupt_occured){                     //if there was an interrupt (rising / falling edge)
            if (edge_type && start_high == 1){      //if the button has just been released (rising edge) and we are passed the starting phase
                i++;                                //increment the counter to move along in the array
                first_seq[i-1] = high_interval;     //store the time interval in the array (dot / dash)
                edge_type = false;                  //set edge_type so that next interrupt it will deal with a button press (falling edge)
                interrupt_occured = 0;              //to indicate we have dealt with the interrupt occuring
            } else {                            
                if (start_low == 1){                //if the button has been pressed and we are past the starting phase
                    i++;                            //increment the counter to move along in the array
                    first_seq[i-1] = low_interval;  //store the time interval (spaces)
                    edge_type = true;               //set the edge_type so that next interrupt will deal with a button released
                    interrupt_occured = 0;          //to indicate we hae dealt with the interrupt occuring     
                }
            }
        }
    }
    i = 0;
}

//takes an array of uint32_t values, times between rising and falling edge interrupts
//converts the times between falling and rising edge to 1's (dashes) and 0's (dots)
void binary_seq(uint32_t intervals[], char test[]){
    int counter = 0;                                                //to increment through the array
    for (int k = 0; k < 8; k++){                                    //to loop over the array of times
        if ((k % 2) == 0){                                          //only deal with the button presses (times between falling and rising edge)
            if (first_seq[k] <= 150000){                            //if button was pressed for less than 0.15 s
            test[counter] = '.';                                    //it is a dot
            } 
            if (first_seq[k] <= 1000000 && first_seq[k] > 150000){  //if button was pressed for between 0.15 and 1 s 
            test[counter] = '-';                                    //it is a dash
            }
            if (first_seq[k] > 1000000){                            //if the button was pressed for more than 1 s
            test[counter] = '?';                                    //it is not recognised
            }
            counter++;                                              //move to the next place in the array
        }  
    }
}

//start handling the arm input array in c
//called after two second no button pressing alarm 
void handle_input(){
    printf("Ready to handle the arm input");

}

// Main entry point of the application
int main() {
    //initialising
    stdio_init_all(); 
    //////////PIO pio = pio0;
    //////////uint offset = pio_add_program(pio, &ws2812_program);
    //////////ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);

    //watchdog_init(); // initialise watchdog timer
    main_asm(); // initialise pins and interrupt
    //////////welcomeMessage(); // print welcome message
    while (1){ //to keep program running so i can pause debugger before program quits

    };
    //////////led_set_blue(); // to indicate that no game is in play 

    get_first_seq(); //get the first sequence of inputs, this will be the player choosing a level
    
    char first_code[4]; //char array to hold 0's and 1's for dots and dashes
    binary_seq(first_seq, first_code); //convert the sequence of uint32_t values into 0's and 1's
    

    while (1){ //to keep program running so i can pause debugger before program quits

    };

    return(0);
}


// Print the welcome message
void welcomeMessage() {
    // 80 char width, pipes inclusive
    printf(".______________________________________________________________________________.\n");
    printf("|                    _____ _____   ____  _    _ _____    __                    |\n");
    printf("|    Conor          / ____|  __ \\ / __ \\| |  | |  __ \\  /_ |            Joe    |\n");
    printf("|    Finlay        | |  __| |__) | |  | | |  | | |__) |  | |        Mulvany    |\n");
    printf("|                  | | |_ |  _  /| |  | | |  | |  ___/   | |                   |\n");
    printf("|    Fionnan       | |__| | | \\ \\| |__| | |__| | |       | |        Tiernan    |\n");
    printf("|    O\'Sullivan     \\_____|_|  \\_\\\\____/ \\____/|_|       |_|         Mullen    |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|         ___           ___           ___           ___           ___          |\n");
    printf("|        /\\__\\         /\\  \\         /\\  \\         /\\  \\         /\\  \\         |\n");
    printf("|       /::|  |       /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\        |\n");
    printf("|      /:|:|  |      /:/\\:\\  \\     /:/\\:\\  \\     /:/\\ \\  \\     /:/\\:\\  \\       |\n");
    printf("|     /:/|:|__|__   /:/  \\:\\  \\   /::\\~\\:\\  \\   _\\:\\~\\ \\  \\   /::\\~\\:\\  \\      |\n");
    printf("|    /:/ |::::\\__\\ /:/__/ \\:\\__\\ /:/\\:\\ \\:\\__\\ /\\ \\:\\ \\ \\__\\ /:/\\:\\ \\:\\__\\     |\n");
    printf("|    \\/__/~~/:/  / \\:\\  \\ /:/  / \\/_|::\\/:/  / \\:\\ \\:\\ \\/__/ \\:\\~\\:\\ \\/__/     |\n");
    printf("|          /:/  /   \\:\\  /:/  /     |:|::/  /   \\:\\ \\:\\__\\    \\:\\ \\:\\__\\       |\n");
    printf("|         /:/  /     \\:\\/:/  /      |:|\\/__/     \\:\\/:/  /     \\:\\ \\/__/       |\n");
    printf("|        /:/  /       \\::/  /       |:|  |        \\::/  /       \\:\\__\\         |\n");
    printf("|        \\/__/         \\/__/         \\|__|         \\/__/         \\/__/         |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\  \\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\__\\   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/__/ \\:|__| /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  \\  \\/__/ \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\  \\        \\:\\  /:/  /   \\:\\  /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\  \\        \\:\\/:/  /     \\:\\/:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\:\\__\\        \\::/  /       \\::/__/       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         ~~            \\/__/                 |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\__\\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::|  |       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:|:|  |      /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /::\\~\\:\\  \\   /:/|:|__|__   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/_\\:\\__\\ /:/\\:\\ \\:\\__\\ /:/ |::::\\__\\ /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  /\\ \\/__/ \\/__\\:\\/:/  / \\/__/~~/:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\ \\:\\__\\        \\::/  /        /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\/:/  /        /:/  /        /:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\::/  /        /:/  /        /:/  /       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         \\/__/         \\/__/                 |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|           Enter a sequence of dots and dashes using GP21 to begin!           |\n");
    printf("|                                                                              |\n");
    printf("|                            Level 1 : .----                                   |\n");
    printf("|                                                                              |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
}


// Return a random character from 0-9 or A-Z when called
char randomChar() {
    char random_char;

    // Use the current microsecond count to seed the random number generator
    uint64_t seed = time_us_64();
    srand(seed);

    // Generate a random number (0 - 9: numbers; 10 - 35: letters)
    int random_num = rand() % 35;

    // If 0 -> 9, return straight away
    // Otherwise, convert the number to an uppercase letter and return the letter
    if (random_num < 10) {
        random_char = random_num + '0';
    } else {
        random_char = (random_num - 10) + 'A';
    }
    char* random_morse = morseCode[random_num];

    // Print statements
    printf("Character: %c | Morse code equivalent: %s", random_char, random_morse);

    // Return character for checking later
    return random_char;

}

// Function to convert an inputed word in morse code into a regular string
char* convertMorse(char* word){
    char* converted = (char*)malloc(MAXSIZE);                           // allocate memory space for output string
    int converted_index = 0, word_index = 0, letter_index = 0;          // initiliase index counters to 0
    char letter[MAXSIZE] = " ";                                         // declare char array to temporarily store each letter

    while(word[word_index] != '\0'){                                    // while there are still more code signals to read in
        if(word[word_index] == ' ')  {                                  // if we read in a space, then we have finished a letter
            word_index++;                                               // increment to next morse code signal for default flow following this if statement
            letter[letter_index] = '\0';                                // null-terminate string containing morse code for the letter
            for (int i = 0; i < 35; i++){                               // for each letter in the alphabet
                if (strcmp(letter,morseCode[i]) == 0){                  // check if the morse code produced so far is equal to a letter in the alphabet
                    if(i < 10)
                        converted[converted_index++] = i + '0';         // add number to output if it is and post-increment converted_index
                    else
                        converted[converted_index++] = (i - 10) + 'A';  // add letter to output if it is and post-increment converted_index
                }               
                letter_index = 0;                                       // start new letter
            }
        }    
                                                     
        letter[letter_index++] = word[word_index++];                    // either way, read in another characted from the input, post incrementing both char arrays
    }
    converted[converted_index] = '\0';                                  // null-terminate output
    return converted;                       
}



char outputChallenge1(){
    char random = randomChar();
    char* randomMorse = malloc(2*sizeof(char));
    randomMorse[0] = random;
    randomMorse[1] = '\0';
    d
}
