#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "pico/stdlib.h"

#include "hardware/gpio.h"
#include "hardware/watchdog.h"
#include "pico/time.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "ws2812.pio.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

#define MAXSIZE 100

char* morseCode[] = {".-", "-...", "-.-.", "-..", ".", "..-.",
    "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-",
    ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};

// Must declare the main assembly entry point before use.
void main_asm();
// Initialise a GPIO pin – see SDK for detail on gpio_init()
void asm_gpio_init(uint pin) {
 gpio_init(pin);
}
// Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
void asm_gpio_set_dir(uint pin, bool out) {
 gpio_set_dir(pin, out);
}
// Get the value of a GPIO pin – see SDK for detail on gpio_get()
bool asm_gpio_get(uint pin) {
 return gpio_get(pin);
}
// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
 gpio_put(pin, value);
}

// Enable falling-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irq(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

// Enable rising-edge interrupt 
void asm_gpio_set_irq1(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}

void welcomeMessage();
char* convertMorse(char* word);

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

static inline void led_set_blue() {
    put_pixel(urgb_u32(0x00, 0x00, 0x7F));
}


//initialise watchdog timer
void watchdog_init(){
    if(watchdog_caused_reboot){
        printf("Game Restarted due to inactivity!\n");
    }
    //enable the watchdogtimer set to the max time, approx 8.3 secs
    //One sets the watchdog timer to pause during debug 
    watchdog_enable(0x7fffff, 0); 
    watchdog_update();
}

//Initialising variables
//need to be global cuz we jump in and out of ASM
int interrupt_occured = 0;               //to indicate that an interrupt needs to be dealt with   
int start_high = 0;                      //set to 1 once first button press has been released (first rising edge interrupt)
int start_low = 0;                       //set to 1 once second button press has occured (second falling edge interrupt)
int i = 0;                               //used to track position in the array
int k = 0;                               //used to track place in first_seq array - if inputting the first char it should = 0, any char after it should = 1
bool edge_type = true;                   //when set to true, the button release is being dealt with. when set to false, button pressed
uint32_t low_interval, high_interval;    //to store the latest time segments
uint32_t time_intervals[100];                 //array to hold the time_intervals input (4 dots/dashes, 3 spaces)
int process_sequence = 0;                //set to 1 when the 2 second alarm timer goes off, program knows to take the users input and process it
int lives = 3;                           //lives set to 3 at the start
int score = 0;                           //score set to 0 at the start


//sets the start_high variable to 1 - to be called from ASM
void set_start_high(int i){
    start_high = i;
}

//sets the start_low variable to 1 - to be called from ASM
void set_start_low(int i){
    start_low = i;
}

//sets the interrupt flag variable to high - to be called from ASM
void check_for_interrupt(int signal){
    interrupt_occured = signal;
}

//stores the interval between button presses
void store_interval_low(int interval){
    low_interval = interval;
}

//stores the interval the button has been pressed for
void store_interval_high(int interval){
    high_interval = interval;
}

//used to put a null terminator on the end of the string of morse code so it can be used in comparison function
void null_terminate_string(char *morse_string){
    int i = 0; //counter
    
    //find the end of the morse code
    while (morse_string[i] == '.' || morse_string[i] == '-'|| morse_string[i] == ' '){
        i++;  
    }

    morse_string[i] = ' '; //space so that it is compatible with ConvertMorse function
    morse_string[i+1] = '\0'; //null terminate
}

//takes an array of uint32_t values, times between rising and falling edge interrupts
//converts the times between falling and rising edge to 1's (dashes) and 0's (dots)
void convert_to_morse(uint32_t intervals[], char *morse_string, int k){
    int counter = 0; 
    while (time_intervals[k] != 0){                                  //to loop over the array of times
        if (time_intervals[k] <= 150000){                            //if button was pressed for less than 0.15 s
        morse_string[counter] = '.';                            //it is a dot
        } 
        if (time_intervals[k] <= 1000000 && time_intervals[k] > 150000){  //if button was pressed for between 0.15 and 1 s 
        morse_string[counter] = '-';                            //it is a dash
        }
        if (time_intervals[k] > 1000000){                            //if the button was pressed for more than 1 s
        morse_string[counter] = ' ';                            //it is not recognised
        }
        counter++;                                              //move to the next place in the array 
        k = k + 2;                                              //move two places in the time_intervals array
    }
    null_terminate_string(morse_string);
}


void handle_gpio_interrupt() {
    if (edge_type && start_high == 1){      //if the button has just been released (rising edge) and we are passed the starting phase
        i++;                                //increment the counter to move along in the array
        time_intervals[i-1] = high_interval;     //store the time interval in the array (dot / dash)
        edge_type = false;                  //set edge_type so that next interrupt it will deal with a button press (falling edge)
        interrupt_occured = 0;              //to indicate we have dealt with the interrupt occuring
    } else {                            
        if (start_low == 1){  //if the button has been pressed and we are past the starting phase
            i++;                            //increment the counter to move along in the array
            time_intervals[i-1] = low_interval;  //store the time interval (spaces)
            edge_type = true;               //set the edge_type so that next interrupt will deal with a button released
            interrupt_occured = 0;          //to indicate we hae dealt with the interrupt occuring  
        } 
      }
}


//start handling the arm input array in c
//called after two second no button pressing alarm 
void handle_input(){
    printf("Ready to handle the arm input");
    process_sequence = 1;
}
// Return a random character from 0-9 or A-Z when called
char randomChar() {
    // Use the current microsecond count to seed the random number generator
    uint64_t seed = time_us_64();
    srand(seed);

    // Generate a random number (0 - 9: numbers; 10 - 35: letters)
    int random_num = rand() % 35;

    // If 0 -> 9, return straight away
    // Otherwise, convert the number to an uppercase letter and return the letter
    if (random_num < 10) {
        return random_num + '0';
    } else {
        return (random_num - 10) + 'A';
    }
}

int level_one() {
    //loop until the player completes the level or runs out of lives
    while (lives != 0 && score != 5){
        char character = randomChar();
        
        // call conors function to output that char and its morse code

        i = 0;                              //global counter for morse code inputs 
        while (process_sequence != 1){      //until the alarm goes off, accept inputs
            if (interrupt_occured){         //input occured
                handle_gpio_interrupt();    //deal with new input  
            }
        }
        process_sequence = 0;               //set to zero so we pause at the while loop the next iteration

        //alarm has gone, convert the sequence of time intervals to morse code
        char morse_sequence[7];                          //only 7 chars since all letters / nums can be represented by 5 dots / dashes
        convert_to_morse(time_intervals, morse_sequence, k);  //convert the sequence to morse code

        char *user_input;                   //string (one char) to hold what the user has input in letters / numbers
        char *morse = morse_sequence;       //string to hold what the user has input in dots and dashes
        user_input = convertMorse(morse);   //conver the dots and dashes to the letter / char

        if (user_input[0] == character){ 
            score++;        //add one to the score and get a new character (start while loop again)
        } else {
            lives--;        //didn't match so minus 1 life and get a new character (start while loop again)
        }

        // call conors function to display the users input and see if it matches to the correct character
        
        //clear the time_intervals array
        int x = 0;
        while(time_intervals[x] != 0){
            time_intervals[x] = 0;
            x++;
        }
        
        //reset variables for the next round (next iteration of the while loop)
        start_high = 0;                                    //to not accept the first interrupt 
        k = 1;                                             //for use in function convert_to_morse. odd time intervals will be used after first round
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round
    }
    

    if (lives == 0){
        return 1; //you lost
    } else {
        return 0; //!! you won 
    }

}

// Main entry point of the application
int main() {
    //initialising
    stdio_init_all(); 
    //////////PIO pio = pio0;
    //////////uint offset = pio_add_program(pio, &ws2812_program);
    //////////ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);

    //watchdog_init(); // initialise watchdog timer
    main_asm(); // initialise pins and interrupt
    //////////welcomeMessage(); // print welcome message
    // while (1){ //to keep program running so i can pause debugger before program quits

    // };
    //////////led_set_blue(); // to indicate that no game is in play 

    int level = 0;
    level = level_one();

    //get_time_intervals(); //get the first sequence of inputs, this will be the player choosing a level
    
    char first_code[4]; //char array to hold 0's and 1's for dots and dashes
    //convert_to_morse(time_intervals, first_code); //convert the sequence of uint32_t values into 0's and 1's
    

    while (1){ //to keep program running so i can pause debugger before program quits

    };

    return(0);
}


// Print the welcome message
void welcomeMessage() {
    // 80 char width, pipes inclusive
    printf(".______________________________________________________________________________.\n");
    printf("|                    _____ _____   ____  _    _ _____    __                    |\n");
    printf("|    Conor          / ____|  __ \\ / __ \\| |  | |  __ \\  /_ |            Joe    |\n");
    printf("|    Finlay        | |  __| |__) | |  | | |  | | |__) |  | |        Mulvany    |\n");
    printf("|                  | | |_ |  _  /| |  | | |  | |  ___/   | |                   |\n");
    printf("|    Fionnan       | |__| | | \\ \\| |__| | |__| | |       | |        Tiernan    |\n");
    printf("|    O\'Sullivan     \\_____|_|  \\_\\\\____/ \\____/|_|       |_|         Mullen    |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|         ___           ___           ___           ___           ___          |\n");
    printf("|        /\\__\\         /\\  \\         /\\  \\         /\\  \\         /\\  \\         |\n");
    printf("|       /::|  |       /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\        |\n");
    printf("|      /:|:|  |      /:/\\:\\  \\     /:/\\:\\  \\     /:/\\ \\  \\     /:/\\:\\  \\       |\n");
    printf("|     /:/|:|__|__   /:/  \\:\\  \\   /::\\~\\:\\  \\   _\\:\\~\\ \\  \\   /::\\~\\:\\  \\      |\n");
    printf("|    /:/ |::::\\__\\ /:/__/ \\:\\__\\ /:/\\:\\ \\:\\__\\ /\\ \\:\\ \\ \\__\\ /:/\\:\\ \\:\\__\\     |\n");
    printf("|    \\/__/~~/:/  / \\:\\  \\ /:/  / \\/_|::\\/:/  / \\:\\ \\:\\ \\/__/ \\:\\~\\:\\ \\/__/     |\n");
    printf("|          /:/  /   \\:\\  /:/  /     |:|::/  /   \\:\\ \\:\\__\\    \\:\\ \\:\\__\\       |\n");
    printf("|         /:/  /     \\:\\/:/  /      |:|\\/__/     \\:\\/:/  /     \\:\\ \\/__/       |\n");
    printf("|        /:/  /       \\::/  /       |:|  |        \\::/  /       \\:\\__\\         |\n");
    printf("|        \\/__/         \\/__/         \\|__|         \\/__/         \\/__/         |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\  \\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\__\\   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/__/ \\:|__| /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  \\  \\/__/ \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\  \\        \\:\\  /:/  /   \\:\\  /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\  \\        \\:\\/:/  /     \\:\\/:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\:\\__\\        \\::/  /       \\::/__/       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         ~~            \\/__/                 |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\__\\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::|  |       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:|:|  |      /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /::\\~\\:\\  \\   /:/|:|__|__   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/_\\:\\__\\ /:/\\:\\ \\:\\__\\ /:/ |::::\\__\\ /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  /\\ \\/__/ \\/__\\:\\/:/  / \\/__/~~/:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\ \\:\\__\\        \\::/  /        /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\/:/  /        /:/  /        /:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\::/  /        /:/  /        /:/  /       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         \\/__/         \\/__/                 |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|           Enter a sequence of dots and dashes using GP21 to begin!           |\n");
    printf("|                                                                              |\n");
    printf("|                            Level 1 : .----                                   |\n");
    printf("|                                                                              |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
}




// Function to convert an inputed word in morse code into a regular string (MUST END WITH A SPACE CHARACTER ' ')
char* convertMorse(char* word){
    if (word == NULL || word[0] == '\0'){
        return NULL;
    }

    char* converted = (char*)malloc(MAXSIZE);               // allocate memory space for output string
    int converted_index = 0;
    int word_index = 0;
    int letter_index = 0;                                   // initiliase index counters to 0
    char letter[MAXSIZE];                                   // declare char array to temporarily store each letter

    while(word[word_index] != '\0'){                        // while there are still more code signals to read in
        if(word[word_index] == ' ')  {                      // if we read in a space, then we have finished a letter
            word_index++;                                   // increment to next morse code signal for default flow following this if statement
            letter[letter_index] = '\0';                    // null-terminate string containing morse code for the letter
            for (int i = 0; i < 26; i++){                   // for each letter in the alphabet
                if (strcmp(letter,morseCode[i]) == 0)       // check if the morse code produced so far is equal to a letter in the alphabet
                    converted[converted_index++] = i + 'A'; // add letter to output if it is and post-increment converted_index               
                letter_index = 0;                           // start new letter
            }
        }                                                    
        letter[letter_index++] = word[word_index++];        // either way, read in another characted from the input, post incrementing both char arrays
    }
    converted[converted_index] = '\0';                      // null-terminate output
    return converted;                       
}
