#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdbool.h>
#include "pico/stdlib.h"

#include "hardware/gpio.h"
#include "hardware/watchdog.h"
#include "pico/time.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "ws2812.pio.h"

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

#define MAXSIZE 100

char* morseCode[] = {"-----", ".----", "..---","...--", "....--", ".....", "-....", "--...", "---..", "----.",".-", "-...", "-.-.", "-..", ".", "..-.",
    "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-",
    ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};

// Must declare the main assembly entry point before use.
void main_asm();
void printStatistics();

/**
 * @brief Initialise a GPIO pin – see SDK for detail on gpio_init()
 * 
 * @param pin Raspberry pin to initialize
 */
void asm_gpio_init(uint pin) {
 gpio_init(pin);
}


/**
 * @brief Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
 * 
 * @param pin Raspberry pin to set direction
 * @param out direction to set pin in 
 */
void asm_gpio_set_dir(uint pin, bool out) {
 gpio_set_dir(pin, out);
}

/**
 * @brief Get the value of a GPIO pin – see SDK for detail on gpio_get()
 * 
 * @param pin Raspberry pin to get value of
 */
bool asm_gpio_get(uint pin) {
 return gpio_get(pin);
}



/**
 * @brief Set the value of a GPIO pin – see SDK for detail on gpio_put()
 * 
 * @param pin Raspberry pin to set value of
 * @param value Value to set pin to 
 */
void asm_gpio_put(uint pin, bool value) {
 gpio_put(pin, value);
}


/**
 * @brief Enable falling-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
 * 
 * @param pin Raspberry pin to set falling edge interupt on 
 */
void asm_gpio_set_irq(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

/**
 * @brief Enable rising-edge interrupt  – see SDK for detail on gpio_set_irq_enabled()
 * 
 * @param pin Raspberry pin to set rising-edge interupt on 
 */
void asm_gpio_set_irq1(uint pin) {
 gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}

void welcomeMessage();
char* convertMorse(char* word);

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

/**
 * @brief Set Led colour to blue
 * 
 */
static inline void led_set_blue() {
    put_pixel(urgb_u32(0x00, 0x00, 0x7F));
}
/**
 * @brief Set Led colour to red
 * 
 */
static inline void led_set_red() {
    put_pixel(urgb_u32(0x7F, 0x00, 0x00));
}
/**
 * @brief Set Led colour to orange
 * 
 */
static inline void led_set_orange() {
    put_pixel(urgb_u32(0xFF, 0x8C, 0x00));
}
/**
 * @brief Set Led colour to yellow
 * 
 */
static inline void led_set_green() {
    put_pixel(urgb_u32(0x00, 0xFF, 0x00));
}
/**
 * @brief Turn LED off
 * 
 */
static inline void led_set_off() {
    put_pixel(urgb_u32(0x00, 0x00, 0x00));
}
/**
 * @brief Set Led colour to yellow
 * 
 */
static inline void led_set_yellow() {
    put_pixel(urgb_u32(0xD7, 0xFF, 0x00));
}

/**
 * @brief Initalise watchdog timer.
 * 
 * enables the watchdogtimer set to the max time, approx 8.3 secs
 */
void watchdog_init(){
    if(watchdog_caused_reboot){
        printf("Game Restarted due to inactivity!\n");
    }
    watchdog_enable(0x7fffff, 0); 
    watchdog_update();
}

//Initialising global variables, necessary for handling arm interrupts
int interrupt_occured = 0;               ///<Brief To indicate that an interrupt needs to be dealt with   
int start_high = 0;                      ///<Brief Set to 1 once first button press has been released (first rising edge interrupt)
int start_low = 0;                       ///<Brief Set to 1 once second button press has occured (second falling edge interrupt)
int i = 0;                               ///<Brief Used to track position in the array
int k = 0;                               ///<Brief Used to track place in first_seq array - if inputting the first char it should = 0, any char after it should = 1
bool edge_type = true;                   ///<Brief When set to true, the button release is being dealt with. when set to false, button pressed
uint32_t low_interval, high_interval;    ///<Brief To store the latest time segments
uint32_t time_intervals[100];            ///<Brief Array to hold the time_intervals input (4 dots/dashes, 3 spaces)
int process_sequence = 0;                ///<Brief Set to 1 when the 2 second alarm timer goes off, program knows to take the users input and process it
int lives = 3;                           ///<Brief Lives set to 3 at the start
int score = 0;                           ///<Brief Score set to 0 at the start
char character;                          ///<Brief The character the user should input morse for
int repeat = 0;                          ///<Brief Used in the levels to repeat the same character or generate another one based on if the user input the correct code
int level_choice;                        ///<Brief To decide which level to play
bool alarm_1_done = false;               ///<Brief Set to true when first 1 second alarm interrupt occurs
bool alarm_2_done = false;               ///<Brief Set to true when first 2 second alarm interrupt occurs

int incorrect_answers = 0;               ///<Brief For incorrect answer statistics
int correct_answers = 0;                 ///<Brief For correct answers statistics


/**
 * @brief Deals with button being released - called from ASM 
 * 
 * Sets the start_high variable to 1. 
 * Sets alarm_1_done and alarm_2_done to false, allowing alarm interrupts to be handled again.
 * 
 * @param i value of 1 passed from arm
 * @see Global Variables: start_high - alarm_1_done - alarm_2_done
 * @see Functions: handle_alarm()
 */
void set_start_high(int i){
    start_high = i;
    alarm_1_done = false;
    alarm_2_done = false;
}


/**
 * @brief Deals with button being pressed - called from ASM 
 * 
 * Sets the start_low variable to 1. 
 * 
 * @param i value of 1 passed from arm
 */
void set_start_low(int i){
    start_low = i;
}

/**
 * @brief Checks for a GPIO interrupt- called from ASM 
 * 
 * Sets the interrupt flag variable to high 
 * 
 * @param signal value of 1 passed from arm when interrupt occurs
 */
void check_for_interrupt(int signal){
    interrupt_occured = signal;
}


/**
 * @brief stores the interval between button presses
 * 
 * @param interval Amount of time between button presses
 */
void store_interval_low(int interval){
    low_interval = interval;
}


/**
 * @brief stores the interval the button has been pressed for
 * 
 * @param interval Amount of time the button has been pressed
 */
void store_interval_high(int interval){
    high_interval = interval;
}

 
/**
 * @brief Places terminator at the end of a string.
 * 
 * Adds a space and a null terminator on a string of morse code so it can be used in comparison function
 * 
 * @param morse_string 
 */
void null_terminate_string(char *morse_string){
    int i = 0; //counter
    
    //find the end of the morse code
    while (morse_string[i] == '.' || morse_string[i] == '-'|| morse_string[i] == ' '){
        i++;  
    }

    morse_string[i] = ' '; 
    morse_string[i+1] = '\0'; 
}



/**
 * @brief Converts time intervals between buttons to 1's (dashes) and 0's (dots)
 * 
 * @param intervals Array of uint32_t values, times between rising and falling edge interrupts
 * @param morse_string Array to store dots and dashes in 
 * @param k position in intervals array
 */
void convert_to_morse(uint32_t intervals[], char *morse_string, int k){
    int counter = 0; 
    while (time_intervals[k] != 0){                             //to loop over the array of times
        if (time_intervals[k] <= 150000){                       //if button was pressed for less than 0.15 s
        morse_string[counter] = '.';                            //it is a dot
        } 
        if (time_intervals[k] <= 1000000 && time_intervals[k] > 150000){  //if button was pressed for between 0.15 and 1 s 
        morse_string[counter] = '-';                            //it is a dash
        }
        if (time_intervals[k] > 1000000){                            //if the button was pressed for more than 1 s
        morse_string[counter] = ' ';                            //it is not recognised
        }
        counter++;                                              //move to the next place in the array 
        k = k + 2;                                              //move two places in the time_intervals array
    }
    null_terminate_string(morse_string);
}

/**
 * @brief Handles GPIO interrupts
 * 
 * @see Global Variables: edge_type, start_high, time_intervals, low_interval, high_interval, interrupt_occurred
 * 
 */
void handle_gpio_interrupt() {
    if (edge_type && start_high == 1){      //if the button has just been released (rising edge) and we are passed the starting phase
        i++;                                //increment the counter to move along in the array
        time_intervals[i-1] = high_interval;//store the time interval in the array (dot / dash)
        edge_type = false;                  //set edge_type so that next interrupt it will deal with a button press (falling edge)
        interrupt_occured = 0;              //to indicate we have dealt with the interrupt occuring
    } else {                            
        if (start_low == 1){                //if the button has been pressed and we are past the starting phase
            i++;                            //increment the counter to move along in the array
            time_intervals[i-1] = low_interval;  //store the time interval (spaces)
            edge_type = true;               //set the edge_type so that next interrupt will deal with a button released
            interrupt_occured = 0;          //to indicate we hae dealt with the interrupt occuring  
        } 
      }
}


/**
 * @brief Prints the Characters to be entered in morse code for level 1 and 2 
 * 
 * Generates a random character from 0-9 or A-Z.
 * Prints the character with or without its morse code equivalent depending on the level.
 * Returns the random character for use by other funcions
 * 
 * @param choose_level The level, 1 or 2, chosen by the player
 * @return char - The random char generated from teh function
 * 
 * @see Global Variables: morseCode[]
 */
char randomChar(int choose_level) {
    char random_char;

    // Use the current microsecond count to seed the random number generator
    uint64_t seed = time_us_64();
    srand(seed);

    // Generate a random number (0 - 9: numbers; 10 - 35: letters)
    int random_num = rand() % 35;

    // If 0 -> 9, return straight away
    // Otherwise, convert the number to an uppercase letter and return the letter
    if (random_num < 10) {
        random_char = random_num + '0';
    } else {
        random_char = (random_num - 10) + 'A';
    }
    char* random_morse = morseCode[random_num];

    // Print statements
    if (choose_level == 1){
        printf("|                 Character: %c | Morse code equivalent: %s                  |\n", random_char, random_morse);
        printf("|                                                                              |\n");
    } else if (choose_level == 2) {
        printf("|                 Character: %c | Morse code equivalent not shown              |\n", random_char);
        printf("|                                                                              |\n");
    }

    // Return character for checking later
    return random_char;

}

/**
 * @brief Handles the alarm timer interrupt
 * 
 * Set up to handle spaces for levels 3 and (Unused).
 * After two one second alarm timer interrupts the programme will process user inputs.
 * Alarm interrupts will then be disblaed until next GPIO input
 * 
 * @see Global Variables: process_sequence, alarm_1_done, alarm_2_done
 */

void handle_alarm(){
    if (!alarm_2_done){
        if (!alarm_1_done){
            alarm_1_done = !alarm_1_done;
        }else{
            process_sequence = 1;
            alarm_2_done = !alarm_2_done;
        }

    }
    return;
}

/**
 * @brief Outputs user input
 * 
 * @param character Users input as an ASCII character
 * @param morse Users input as morse
 */
void output_user_input(char character, char *morse){
    printf("|                                                                              |\n");
    printf("|                        You input %s : %c                                    |\n", morse, character);
    printf("|                                                                              |\n");
    return;
}




/**
 * @brief printing entry message level 1
 */
void print_level_one(){
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|                            Welcome to Level 1                                |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    return;
}


/**
 * @brief printing entry message level 2
 */
void print_level_two(){
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|                            Welcome to Level 2                                |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    return;
}
/**
 * @brief Printing game complete message 
 * 
 */
void print_game_complete(){
    printf(".__.\n");
    printf("|                                                                              |\n");
    printf("|                Congratulations! You have completed the game                  |\n");
    printf("|                                                                              |\n");
    printf(".__.\n");
    return;
}
/**
 * @brief Printing level complete message and statistics
 * 
 * @param choose_level level chosen by user
 */
void level_complete_message(int choose_level){
    if (choose_level == 1){
        printf("|                     Congratulations, you passed level 1 !                    |\n");
        printf("|                                                                              |\n");
        printf(".______________________________________________________________________________.\n");
        level_choice = 2;
    } else if (choose_level == 2){
        printf("|                     Congratulations, you passed level 2 !                    |\n");
        printf("|                                                                              |\n");
        printf(".______________________________________________________________________________.\n");
        print_game_complete();
        while (true);
   
        
    }
    printStatistics(); // Print statistics relating to performance
}


/**
 * @brief used to clear the array storing the timer intervals
 * 
 */
void clear_time_intervals(){
    int x = 0;
        while(time_intervals[x] != 0){
            time_intervals[x] = 0;
            x++;
        }
}



/**
 * @brief Runs level 1 and 2.
 * 
 * Handles all inputs, outputs and corresponding logic for levels 1 and 2 
 * 
 * @param choose_level Level chosen by player 
 * @return int - Return 1 if lost, return 0 if won 
 * 
 * @see Global Variables: incorrect_answers, correct_answers, lives, score, repeat, level_choice, character, process_sequence, interrupt_occured, time_intervals, morse_sequence, k, start_high
 */
int level_one_and_two(int choose_level) {
    if (choose_level == 1){ //print the level 1 entry message
        print_level_one();
    } else if (choose_level == 2) { //print the level 2 entry message
        print_level_two();
    } else {
        printf("error in choosing level!\n"); //print error
    }

    //char character; 
    //loop until the player completes the level or runs out of lives
    while (lives != 0 && score != 5){
        //output the colour corresponding to the amount of lives yet
        switch (lives) {
        case 3: 
            led_set_green();
            break;
        case 2:
            led_set_orange();
            break;
        case 1:
            led_set_yellow();
            break;
        default:
            break;
        }

        if (repeat == 1){ //if the user input the wrong sequence of morse code
            printf("|                                Try again !                                   |\n");
            printf("|                                                                              |\n");
        } else { //output a new random character for the user to input
            character = randomChar(level_choice);
          } 
        
        i = 0;                              //global counter for morse code inputs 
        while (process_sequence != 1){      //until the alarm goes off, accept inputs
            if (interrupt_occured){         //input occured
                handle_gpio_interrupt();    //deal with new input  
            }
        }
        process_sequence = 0;               //set to zero so we pause at the while loop the next iteration

        //alarm has gone, convert the sequence of time intervals to morse code
        char morse_sequence[7];                          //only 7 chars since all letters / nums can be represented by 5 dots / dashes
        convert_to_morse(time_intervals, morse_sequence, k);  //convert the sequence to morse code

        char *user_input;                   //string (one char) to hold what the user has input in letters / numbers
        char *morse = morse_sequence;       //string to hold what the user has input in dots and dashes
        user_input = convertMorse(morse);   //conver the dots and dashes to the letter / char

        output_user_input(*user_input, morse); //output the users input

        if (user_input[0] == character){  //if the users input is correct
            score++;        //add one to the score and get a new character (start while loop again)
            correct_answers++; // Increment correct guesses for statistics
            if (lives < 3){ //if we are not already on 3 lives, add another life
                lives++;
            }
            repeat = 0; //set repeat to 0 so that we get a new character on the next iteration
        } else {
            lives--;        //didn't match so minus 1 life and get a new character (start while loop again)
            score = 0;
            repeat = 1;     //set repeat to 1 since we need the user to attempt the same character again
            incorrect_answers++; // Increment incorrect guesses for statistics
        }
        
        //clear the time_intervals array
        clear_time_intervals();
        
        //reset variables for the next round (next iteration of the while loop)
        start_high = 0;                                    //to not accept the first interrupt 
        k = 1;                                             //for use in function convert_to_morse. odd time intervals will be used after first round
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round
    }
    

    if (lives == 0){
        led_set_red(); //set led to red 
        printf("|                You have failed to complete the level :(                      |\n");
        printf("|                                                                              |\n");
        printf(".______________________________________________________________________________.\n");
        printStatistics(); // print statistics relating to performance
        lives = 3;  //reset lives
        score = 0;  //reset score
        repeat = 0; //don't enter repeat next iteration
        // Reset statistic variables at the start of a new level
        incorrect_answers = 0;
        correct_answers = 0;
        return 1;   //you lost
    } else {
        led_set_yellow();   //set the LED to yellow to indicate you won (PROB CHANGE THIS !)
        level_complete_message(level_choice); //print winning message
        lives = 3;  //reset lives
        score = 0;  //reset score
        // Reset statistic variables at the start of a new level
        incorrect_answers = 0;
        correct_answers = 0;
            
        return 0;   //!! you won 
    }

}




int choose_level() {
    while (process_sequence != 1){      //until the alarm goes off, accept inputs
        if (interrupt_occured){         //input occured
            handle_gpio_interrupt();    //deal with new input  
        }
    }
    process_sequence = 0;               //set to 0 so that we enter the while loop on the next iteration

    char morse_sequence[7];                          //only 7 chars since all letters / nums can be represented by 5 dots / dashes
    convert_to_morse(time_intervals, morse_sequence, k);  //convert the sequence to morse cod  

    char *morse = morse_sequence;       //string to hold what the user has input in dots and dashes
    
    if (strcmp(morse,".---- ") == 0){
        clear_time_intervals();                            //clear the array of time intervals
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round
        k = 1;                                             //set k to 1 so we take every odd interval from the time array (see function convert_to_morse)
        return 1; //level one selected
    } else if (strcmp(morse,"..--- ") == 0) {
        clear_time_intervals();                            //clear the array of time intervals
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round    
        k = 1;                                             //set k to 1 so we take every odd interval from the time array (see function convert_to_morse)
        return 2; //level two selected
    } else {
        clear_time_intervals();                            //clear the array of time intervals
        memset(morse_sequence, 0, sizeof(morse_sequence)); //clear the string for next round    
        i = 0;                                             //set the index counter of the time_interval to zero
        k = 1;                                             //set the index counter of the morse code array to zero
        return 0; //no level selected
    }


}

// Main entry point of the application
int main() {
    //initialising
    stdio_init_all(); 
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &ws2812_program);
    ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);

    watchdog_init(); // initialise watchdog timer
    main_asm(); // initialise pins and interrupt
    welcomeMessage(); // print welcome message
    
    led_set_blue(); // to indicate that no game is in play 


    while (level_choice == 0){ //NEEDS TO BE MADE ROBUST
        level_choice = choose_level(); //get the users input for level choice
        if (level_choice == 1 || level_choice == 2){ break; }
        printf("|                                                                              |\n");
        printf("|               Error when choosing level. Please choose again.                |\n");
        printf("|                                                                              |\n");
    }

    int level; //placeholder
    level = level_one_and_two(level_choice);   //start whichever level the user chose
    if (level == 0){ //if we passed level 1, go to level 2
        level = level_one_and_two(level_choice);   //start whichever level the user chose
    }

    while (1){ //to keep program running so i can pause debugger before program quits

    };

    return(0);
}


// Print the welcome message
void welcomeMessage() {
    // 80 char width, pipes inclusive
    printf(".______________________________________________________________________________.\n");
    printf("|                    _____ _____   ____  _    _ _____    __                    |\n");
    printf("|    Conor          / ____|  __ \\ / __ \\| |  | |  __ \\  /_ |            Joe    |\n");
    printf("|    Finlay        | |  __| |__) | |  | | |  | | |__) |  | |        Mulvany    |\n");
    printf("|                  | | |_ |  _  /| |  | | |  | |  ___/   | |                   |\n");
    printf("|    Fionnan       | |__| | | \\ \\| |__| | |__| | |       | |        Tiernan    |\n");
    printf("|    O\'Sullivan     \\_____|_|  \\_\\\\____/ \\____/|_|       |_|         Mullen    |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|         ___           ___           ___           ___           ___          |\n");
    printf("|        /\\__\\         /\\  \\         /\\  \\         /\\  \\         /\\  \\         |\n");
    printf("|       /::|  |       /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\        |\n");
    printf("|      /:|:|  |      /:/\\:\\  \\     /:/\\:\\  \\     /:/\\ \\  \\     /:/\\:\\  \\       |\n");
    printf("|     /:/|:|__|__   /:/  \\:\\  \\   /::\\~\\:\\  \\   _\\:\\~\\ \\  \\   /::\\~\\:\\  \\      |\n");
    printf("|    /:/ |::::\\__\\ /:/__/ \\:\\__\\ /:/\\:\\ \\:\\__\\ /\\ \\:\\ \\ \\__\\ /:/\\:\\ \\:\\__\\     |\n");
    printf("|    \\/__/~~/:/  / \\:\\  \\ /:/  / \\/_|::\\/:/  / \\:\\ \\:\\ \\/__/ \\:\\~\\:\\ \\/__/     |\n");
    printf("|          /:/  /   \\:\\  /:/  /     |:|::/  /   \\:\\ \\:\\__\\    \\:\\ \\:\\__\\       |\n");
    printf("|         /:/  /     \\:\\/:/  /      |:|\\/__/     \\:\\/:/  /     \\:\\ \\/__/       |\n");
    printf("|        /:/  /       \\::/  /       |:|  |        \\::/  /       \\:\\__\\         |\n");
    printf("|        \\/__/         \\/__/         \\|__|         \\/__/         \\/__/         |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\  \\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::\\  \\       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\     /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /:/  \\:\\  \\   /:/  \\:\\__\\   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/ \\:\\__\\ /:/__/ \\:\\__\\ /:/__/ \\:|__| /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  \\  \\/__/ \\:\\  \\ /:/  / \\:\\  \\ /:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\  \\        \\:\\  /:/  /   \\:\\  /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\  \\        \\:\\/:/  /     \\:\\/:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\:\\__\\        \\::/  /       \\::/__/       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         ~~            \\/__/                 |\n");
    printf("|               ___           ___           ___           ___                  |\n");
    printf("|              /\\  \\         /\\  \\         /\\__\\         /\\  \\                 |\n");
    printf("|             /::\\  \\       /::\\  \\       /::|  |       /::\\  \\                |\n");
    printf("|            /:/\\:\\  \\     /:/\\:\\  \\     /:|:|  |      /:/\\:\\  \\               |\n");
    printf("|           /:/  \\:\\  \\   /::\\~\\:\\  \\   /:/|:|__|__   /::\\~\\:\\  \\              |\n");
    printf("|          /:/__/_\\:\\__\\ /:/\\:\\ \\:\\__\\ /:/ |::::\\__\\ /:/\\:\\ \\:\\__\\             |\n");
    printf("|          \\:\\  /\\ \\/__/ \\/__\\:\\/:/  / \\/__/~~/:/  / \\:\\~\\:\\ \\/__/             |\n");
    printf("|           \\:\\ \\:\\__\\        \\::/  /        /:/  /   \\:\\ \\:\\__\\               |\n");
    printf("|            \\:\\/:/  /        /:/  /        /:/  /     \\:\\ \\/__/               |\n");
    printf("|             \\::/  /        /:/  /        /:/  /       \\:\\__\\                 |\n");
    printf("|              \\/__/         \\/__/         \\/__/         \\/__/                 |\n");
    printf(".______________________________________________________________________________.\n");
    printf("|                                                                              |\n");
    printf("|           Enter a sequence of dots and dashes using GP21 to begin!           |\n");
    printf("|                                                                              |\n");
    printf("|                            Level 1 : .----                                   |\n");
    printf("|                            Level 2 : ..---                                   |\n");
    printf("|                                                                              |\n");
    printf(".______________________________________________________________________________.\n");
}


char* convertMorse(char* word){
    char* converted = (char*)malloc(MAXSIZE);                           // allocate memory space for output string
    int converted_index = 0, word_index = 0, letter_index = 0;          // initiliase index counters to 0
    char letter[MAXSIZE] = " ";                                         // declare char array to temporarily store each letter
    bool found = false;

    while(word[word_index] != '\0'){                                    // while there are still more code signals to read in
        if(word[word_index] == ' ')  {                                  // if we read in a space, then we have finished a letter
            word_index++;                                               // increment to next morse code signal for default flow following this if statement
            letter[letter_index] = '\0';                                // null-terminate string containing morse code for the letter
            for (int i = 0; i < 35; i++){                               // for each letter in the alphabet
                if (strcmp(letter,morseCode[i]) == 0){                  // check if the morse code produced so far is equal to a letter in the alphabet
                    found = true;                                       // set found to true
                    if(i < 10)
                        converted[converted_index++] = i + '0';         // add number to output if it is and post-increment converted_index
                    else
                        converted[converted_index++] = (i - 10) + 'A';  // add letter to output if it is and post-increment converted_index
                }               
                letter_index = 0;                                       // start new letter
            }
            if(!found){                                                 // if no letter found
                converted[converted_index++] = '?';                     // set letter to ? for unknown        
            }
            found = false;                                              // set found to false regardless
        }    
                                                     
        letter[letter_index++] = word[word_index++];                    // either way, read in another characted from the input, post incrementing both char arrays
    }
    converted[converted_index] = '\0';                                // null-terminate output (removing trailing question mark)
    return converted;                       
}

void printStatistics() {
    // Calculate accuracy of correct answers
    double accuracy;
    double total_accuracy = (correct_answers + incorrect_answers) * 1.0;
    double correct_accuracy = correct_answers * 1.0;
    accuracy = (correct_accuracy / total_accuracy) * 100.0;

    // Handle different spacings for different number sizes
    char incorrect_spacing[3];
    char correct_spacing[3];
    char accuracy_spacing[3];
    // Incorrect Answers
    if (incorrect_answers >= 100) { // If answers has 3 digits, print all digits
        incorrect_spacing[0] = '\0';
    } else if (incorrect_answers >= 10) { // If answers has 2 digits, print 2 digits and 1 space
        incorrect_spacing[0] = ' ';
        incorrect_spacing[1] = '\0';
    } else { // If answers has 1 digits, print 1 digit and 2 spaces
        incorrect_spacing[0] = ' ';
        incorrect_spacing[1] = ' ';
        incorrect_spacing[2] = '\0';
    }
    // Correct Asnwers
    if (correct_answers >= 100) { // If answers has 3 digits, print all digits
        correct_spacing[0] = '\0';
    } else if (correct_answers >= 10) { // If answers has 2 digits, print 2 digits and 1 space
        correct_spacing[0] = ' ';
        correct_spacing[1] = '\0';
    } else { // If answers has 1 digits, print 1 digit and 2 spaces
        correct_spacing[0] = ' ';
        correct_spacing[1] = ' ';
        correct_spacing[2] = '\0';
    }
    // Accuracy
    if (accuracy == 100) {
        accuracy_spacing[0] = '\0';
    } else if (accuracy >= 10) { // If accuracy is greater than 10% (total 4 digits XX.XX)
        accuracy_spacing[0] = ' ';
        accuracy_spacing[1] = '\0';
    } else { // If accuracy is less than 10% (total 3 digits X.XX)
        accuracy_spacing[0] = ' ';
        accuracy_spacing[1] = ' ';
        accuracy_spacing[2] = '\0';
    }

    printf("|                          -----Level Statistics-----                          |\n");
    printf("|                            Incorrect Answers:  %d%s                           |\n", incorrect_answers, incorrect_spacing);
    printf("|                            Correct Answers:    %d%s                           |\n", correct_answers, correct_spacing);
    printf("|                            Hitrate Percentage: %0.2f%s                        |\n", accuracy, accuracy_spacing);
    printf(".______________________________________________________________________________.\n");
}
